## Gitlet 设计文档

### 1. Gitlet 需求分析

Git中重要的对象：

* blobs：文件保存的内容。由于 Gitlet 会保存文件的多版本，一个文件可能对应多个 blob：每个 blob 都在不同的提交中被跟踪。
* trees：目录结构映射名称到指向blob和其他树（子目录）的引用
* commits：组合了日志消息、其他元数据（提交日期、作者等）、对树的引用以及对父提交的引用。仓库还维护从分支头到提交引用的映射，以便某些重要的提交有符号名称。

Gitlet进行了一些简化：

* 将树结构整合到commit中，并且不处理子目录（因此每个仓库将有一个“扁平”的纯文件目录）。
* 我们将仅限于引用两个父节点的合并（在真实的Git中，可以有任意数量的父节点）。
* 我们的元数据仅由时间戳和日志消息组成。因此，一个commit将包括日志消息、时间戳、文件名到对象引用的映射、父引用，以及（对于合并操作）第二个父引用。

我们这里的每个对象——每个blob和每个提交——都有一个唯一的整数ID，用作对象的引用。

幸运的是，有用于计算SHA-1值的库类，因此你不必处理实际算法。你只需要确保正确标记所有对象。在哈希commit时包含所有元数据和引用。以某种方式区分用于commit的哈希和用于blobs的哈希。一个好的做法是在.gitlet目录内设计一个周密的目录结构。另一种方法是对于commit的哈希和blobs的哈希，额外添加一个不同的词一起哈希。

顺便说一下，SHA-1哈希值以40个字符的十六进制字符串形式表示，可以作为存储您数据在.gitlet目录下的方便文件名（下面会详细说明）。它还为您提供了一种方便的方法来比较两个文件（blob），以查看它们是否包含相同的内容：如果它们的SHA-1值相同，我们就简单地假设这两个文件是相同的。

推送意味着将远程仓库尚未拥有的所有提交和对象复制到远程仓库，并重置一个分支引用。拉取与此相同，但方向相反。远程仓库在这个项目中是额外加分，不是获得满分所必需的。

由于Java的序列化功能，从文件读取和写入您的内部对象实际上非常容易。

commit包含文件名和指向这些对象的引用，以及一个父链接。

我们唯一给出的结构要求是，你必须有一个名为gitlet.Main的类，并且它必须有一个main方法。

我们还添加了两个建议类：Commit 和 Repository 来帮助你开始。当然，你可以编写额外的 Java 类来支持你的项目，或者如果你愿意，也可以移除我们建议的类。但不要使用任何外部代码（除了 JUnit），也不要使用任何 Java 之外的编程语言。你可以使用你想要的全部 Java 标准库，以及我们提供的工具。

你不应该在主类中做所有的事情。你的主类应该主要调用存储库类中的辅助方法。查看lab6中的CapersRepository和Main类，以了解我们推荐的结构示例。

本规范（Spec）的大部分内容将描述 Gitlet.java的 main 方法在接收到作为命令行参数的各种 gitlet 命令时，应当如何做出响应。但在我们逐条拆解各个命令之前，以下是整个项目都需要满足的一些总体准则：

* 为了让 Gitlet 能够工作，它需要一个地方来存储旧版本的文件和其他元数据。所有这些内容都必须存储在一个名为 .gitlet 的目录中，就像真实 git 系统将此信息存储在 .git 目录中一样（以 . 开头的文件是隐藏文件。在大多数操作系统中，默认情况下您将无法看到它们。在 Unix 中，命令 ls -a 将显示它们。）如果某个特定位置有一个 .gitlet 目录，则 Gitlet 系统被认为是“已初始化”的。大多数 Gitlet 命令（除了 init 命令）只需要在已初始化 Gitlet 系统的目录中使用时才能工作——也就是说，一个包含 .gitlet 目录的目录。不在您的 .gitlet 目录中的文件（这些文件是您正在使用的仓库中的文件副本，以及您计划添加到仓库中的文件）被称为您的工作目录中的文件。
* 大多数命令都有运行时或内存使用要求。你必须遵循这些。其中一些运行时被描述为常数“相对于任何显著度量”。显著度量包括：任何关于文件数量或大小的度量，任何关于提交次数的度量。你可以忽略序列化或反序列化所需的时间，但有一个例外，即你的序列化时间不能以任何方式依赖于已添加、提交等文件的总大小（什么是序列化？如果你不知道，请重新回顾lab6！）你也可以假设从哈希表中获取是常数时间。
* 有些命令存在特定的错误情况，并带有指定的错误消息。这些错误消息的确切格式将在规范中后面详细说明。所有错误消息都以句号结尾；由于我们的自动评分是逐字进行的，请务必包含它。如果您的程序遇到这些错误情况之一，它必须打印错误消息，并且不能更改任何其他内容。您不需要处理除列出的错误情况之外的任何其他错误情况。
* 有一些失败情况需要处理，但它们不适用于特定的命令。以下是这些情况：
  * 如果用户没有输入任何参数，则打印消息“Please enter a command.”然后退出。
  * 如果用户输入一个不存在的命令，打印消息“No command with that name exists.”并退出。
  * 如果用户输入的命令操作数数量或格式错误，则打印消息“Incorrect operands.”并退出。
  * 如果用户输入一个需要处于已初始化的 Gitlet 工作目录（即包含 .gitlet 子目录）的命令，但当前不在这样的目录中，则打印消息“Not in an initialized Gitlet directory.”

请勿打印除规范要求之外的内容。如果打印了必要之外的信息，我们的一些自动评分测试将会失效。

要立即退出您的程序，您可以调用 System.exit(0)。例如，如果在一个辅助函数中间发生错误，并且您希望 gitlet 立即终止，您就会调用这个函数。注意：您应该始终向 System.exit(0) 命令提供参数 0。在 61C 课程中，您将学习这个参数（称为错误代码）的含义。

现在我们逐一详细说明您必须支持的每个命令。请记住，优秀的程序员总是关心他们的数据结构：当您阅读这些命令时，您应该首先考虑如何存储您的数据以便轻松支持这些命令，其次考虑是否有机会重用您已经实现的命令（提示：在这个项目中，您在项目2的早期部分已经编写了可以在项目2的后期部分大量重用的代码）。我们列出了一些对我们有用的讲座，但您不必须使用这些讲座中的概念。对于一些较难理解的命令，我们提供了概念性测验，您应该使用它们来检查您的理解。这些测验不计入成绩，它们只是帮助您在尝试实现命令之前检查您的理解。

#### init

* 用法：java gitlet.Main init
* 描述：在当前目录中创建一个新的 Gitlet 版本控制系统。该系统将自动以一个提交开始：一个不包含文件且提交信息为 initial commit（就像这样，没有标点符号）的提交。它将有一个分支：master，最初指向这个初始提交，并且 master 将是当前分支。这个初始提交的时间戳将是 00:00:00 UTC, Thursday, 1 January 1970,以你选择的日期格式表示（这被称为“（Unix）纪元”，内部表示为时间 0）。由于 Gitlet 创建的所有仓库中的初始提交都完全相同，因此所有仓库将自动共享这个提交（它们将具有相同的 UID），并且所有仓库中的所有提交都将追溯到它。
* 运行时间：应相对于任何重要指标保持恒定。
* 失败情况：如果当前目录中已经存在一个 Gitlet 版本控制系统，它应该中止。它不应该用一个新的系统覆盖现有的系统。应该打印错误信息“A Gitlet version-control system already exists in the current directory.”
* 有危险吗？不
* 我们的行数：~15

#### add

* 用法：java gitlet.Main add [文件名]
* 描述：将文件当前版本的一个副本添加到暂存区（请参考commit命令的描述）。因此，添加文件也称为暂存待添加文件。暂存一个已经暂存的文件会使用新内容覆盖暂存区中的旧条目。暂存区应该位于 .gitlet 目录中。如果文件当前工作版本与当前提交中的版本相同，则无需暂存添加，如果它已经在暂存区中，则应将其移除（这通常发生在文件被修改、添加，然后又改回原始版本时）。如果该文件在执行命令时正处于暂存删除状态（参见 gitlet rm），则它将不再被暂存删除。
* 运行时间：在最坏情况下，应该相对于所添加文件的大小和lgN线性运行，其中N是提交中的文件数量。
* 错误情况：如果文件不存在，打印错误信息“File does not exist.”然后不进行任何更改退出。
* 有危险吗？不
* 我们的行数：~20
* 与真实git的差异：在真实git中，可以一次性添加多个文件。在gitlet中，一次只能添加一个文件。

#### commit

* 用法：java gitlet.Main commit [消息]

* 描述：将当前commit和暂存区的跟踪文件快照保存下来，以便稍后可以恢复，并创建一个新的commit。该commit被认为在跟踪保存的文件。默认情况下，每个commit的文件快照将与其父提交的文件快照完全相同；它会保持文件版本不变，不会更新它们。当提交时，只有跟踪且已暂存为添加的文件内容会被更新，此时commit将包含暂存版本的文件，而不是从父提交中获取的版本。commit会保存并开始跟踪其父commit未跟踪但已暂存为添加的任何文件。最后，当前commit中跟踪的文件可能会在新commit中变为未跟踪，因为它们被 rm 命令（下方）暂存为删除。

  总之：默认情况下，一个提交（commit）具有与其父commit相同的文件内容。已标记为添加和删除的文件是提交的更新。当然，日期（以及可能的消息）也会与父commit不同。

  关于提交的一些额外说明：

  * 提交后暂存区会被清空。
  * 提交命令不会添加、更改或删除工作目录中的文件（除了.gitlet目录中的文件）。rm命令会删除这些文件，并将它们暂存为删除，以便在提交后不再跟踪。
  * 对已暂存添加或删除的文件所做的任何更改都将被提交命令忽略，该命令仅修改.gitlet目录的内容。例如，如果你使用Unix的rm命令（而不是同名Gitlet命令）删除一个已跟踪的文件，它对下一个提交没有影响，该提交仍然包含（现已删除）的文件版本。
  * commit命令后，新的commit作为提交树中的一个新节点被添加。
  * 刚刚提交的commit成为“当前commit”，HEAD指针现在指向它。之前的HEAD提交是此commit的父commit。
  * 每个commit都应包含其创建的日期和时间。
  * 每个commit都有关联的日志消息，该消息描述了提交中文件的变化。这是由用户指定的。整个消息应只占用传递给main的args数组中的一个条目。要包含多词消息，你必须在它们周围加上引号。
  * 每个commit都由其SHA-1 id标识，它必须包括其文件（blob）引用、父引用、日志消息和提交时间。

* 运行时间：运行时间应与提交次数的任何度量保持恒定。运行时间必须与提交所跟踪的文件总大小呈线性关系或更好。此外，此命令有内存需求：提交必须使 .gitlet 目录的大小增加不超过提交时待添加文件的总大小，不包括额外的元数据。这意味着不要存储提交从其父提交接收的文件版本的冗余副本（提示：记住对象是内容寻址的，并利用 SHA1 的优势）。您可以保存整个额外的文件副本；不用担心只保存差异或类似的东西。

* 失败情况：如果没有文件被暂存，则中止。打印消息“No changes added to the commit.”。每个提交都必须有一个非空消息。如果没有，则打印错误消息“Please enter a commit message.”。跟踪文件从工作目录中缺失或在工作目录中更改不是失败。完全忽略.gitlet目录之外的所有内容。

* 有危险吗？没有

* 与真实git的差异：在真实的git中，提交可以有多个父提交（由于合并），并且拥有相当多的元数据。

* 我们的行数：~35

#### rm

* 用法：java gitlet.Main rm [文件名]
* 描述：如果文件当前已暂存，则取消暂存。如果文件在当前提交中被跟踪，则暂存它以供删除，并且如果用户尚未这样做，则从工作目录中删除该文件（除非它在当前提交中被跟踪，否则不要删除它）。
* 运行时间：应相对于任何重要度量以恒定时间运行。
* 失败案例：如果文件既没有被暂存也没有被HEAD提交跟踪，则打印错误信息“No reason to remove the file.”
* 危险吗？是。（但是如果你使用我们的实用方法，你只会伤害你的存储库文件，而不会伤害你目录中的所有其他文件。）
* 我们的行数：~20

#### log

* 用法：java gitlet.Main log
* 描述：从当前头提交开始，沿着提交树向后显示每个提交的信息，直到初始提交，遵循第一个父提交链接，忽略合并提交中发现的任何第二个父提交。（在常规 Git 中，这就是使用 git log --first-parent 得到的结果）。这一系列提交节点称为提交的历史。对于这个历史中的每个节点，它应该显示的信息是提交 ID、提交时间以及提交信息。将最新的提交显示在顶部。顺便提一下，你会发现 Java 类 java.util.Date 和 java.util.Formatter 对于获取和格式化时间非常有用。请去研究一下这两个类，而不要试图自己手动构建时间格式！对于合并提交（那些有两个父提交的)，在“Merge:”后面的两个十六进制数字由第一个和第二个父提交ID的前七个数字组成，按顺序排列。第一个父提交是你执行合并时所在的分支；第二个是合并进来的分支。这和常规Git一样。
* 运行时间：应与头部历史中节点数量的线性关系。
* 失败案例：无
* 有危险吗？不
* 我们的行数：~20

#### global-log

* 用法：java gitlet.Main global-log
* 描述：类似于日志，但会显示所有曾经做出的提交信息。提交的顺序并不重要。提示：gitlet.Utils 中有一个有用的方法可以帮助你遍历目录中的文件。
* 运行时间：与之前做出的提交数量呈线性关系。
* 故障案例：无
* 有危险吗？不
* 我们的行数：~10

#### find

* 用法：java gitlet.Main find [提交信息]
* 描述：打印出所有具有给定提交信息的commit ID，每个ID占一行。如果有多个这样的提交，则将它们的ID分别打印在不同的行上。提交信息是一个操作数；要表示多词信息，请将操作数放在引号中，如下面的提交命令所示。提示：此命令的提示与global-log的提示相同。
* 运行时间：应与提交次数成线性关系。
* 失败案例：如果不存在这样的提交，则打印错误信息Found no commit with that message.”
* 有危险吗？不
* 与真实git的差异：在真实git中不存在。可以通过grep日志输出来实现类似的效果。
* 我们的行数：~15

#### status

* 用法：java gitlet.Main status

* 描述：显示当前存在的分支，并用*标记当前分支。还显示已暂存以供添加或删除的文件。最后两个部分（未暂存修改和未跟踪文件）是附加分，共32分。你可以将它们留空（只保留标题）。各个部分之间有一个空行，整个状态也以一个空行结束。条目应按词典顺序排列，使用Java字符串比较顺序（星号不计入）。

  工作目录中的一个文件是“已修改但未暂存”，如果它是

  * 当前提交中已跟踪，工作目录中已更改，但未暂存
  * 已暂存添加，但与工作目录中的内容不同
  * 已暂存添加，但在工作目录中已删除
  * 未标记为删除，但在当前提交中跟踪，并已从工作目录中删除

  最后一个类别（“未跟踪文件”）是用于工作目录中存在但既未标记为添加也未跟踪的文件。这包括那些已经被标记为删除，但随后在没有 Gitlet 的知识下重新创建的文件。忽略可能引入的任何子目录，因为 Gitlet 不处理它们。

* 运行时：确保这仅取决于工作目录中的数据量加上待添加或删除的文件数量再加上分支数量。

* 故障案例：无

* 有危险吗？不

* 我们的行数：~45

#### checkout

Checkout 是一种通用命令，根据其参数的不同可以执行几件不同的事情。有三种可能的用例。在下面的每个部分中，您将看到三个编号点。每个点对应 checkout 的相应用法。

* 用法

  * java gitlet.Main checkout -- [文件名]
  * java gitlet.Main checkout [commit ID] -- [文件名]
  * java gitlet.Main checkout [分支名称]

* 描述

  * 将文件在头提交中存在的版本放入工作目录，如果有已存在的版本，则覆盖它。新版本的文件没有被暂存。
  * 将指定提交 ID 中文件存在的版本放入工作目录，如果该文件已存在，则覆盖其现有版本。新版本的文件未被暂存。
  * 将指定分支HEAD提交中的所有文件移动到工作目录，如果这些文件已存在，则覆盖它们。此外，在此命令结束时，指定的分支将被视为当前分支（HEAD）。当前分支中跟踪但未在已检出的分支中存在的任何文件将被删除。暂存区将被清空，除非已检出的分支是当前分支（见下文故障案例）。

* 运行时间

  * 应该与正在检查的文件大小成线性关系。
  * 应该与提交快照中文件的总大小成线性关系。应该与涉及提交数量的任何度量成常数关系。应该与分支数量成常数关系。

* 失败案例

  * 如果文件在之前的提交中不存在，则中止，并打印错误消息“File does not exist in that commit.”。不要更改当前工作目录。
  * 如果没有给定ID的提交存在，则打印“No commit with that id exists.”。否则，如果给定提交中不存在该文件，则打印与失败情况1相同的消息。不要更改当前工作目录。
  * 如果不存在以该名称命名的分支，则打印“No such branch exists.”。如果该分支是当前分支，则打印“No need to checkout the current branch.”。如果当前分支中有未跟踪的工作文件，并且这些文件将被检出操作覆盖，则打印“There is an untracked file in the way; delete it, or add and commit it first.”并退出；在进行任何其他操作之前执行此检查。不要更改当前工作目录。

  与真实git的差异：真实的git不会清除暂存区，并且会暂存已检出的文件。此外，它不会执行会导致覆盖或撤销暂存更改（添加或删除）的检出操作。

* 有危险吗？不

* 我们的行数

  * ~15
  * ~5
  * ~15

#### branch

* 用法：java gitlet.Main branch [分支名称]
* 描述：使用给定的名称创建一个新分支，并将其指向当前的HEAD提交。分支不过是一个引用（一个SHA-1标识符）到一个提交节点的名称。此命令不会立即切换到新创建的分支（就像在真实的Git中一样）。在您调用branch之前，您的代码应该正在默认分支“master”上运行。
* 运行时间：应相对于任何重要指标保持恒定。
* 失败案例：如果给定名称的分支已存在，则打印错误消息“A branch with that name already exists.”
* 有危险吗？不
* 我们的行数：~10

#### rm-branch

* 用法：java gitlet.Main rm-branch [分支名称]
* 描述：删除指定名称的分支。这仅意味着删除与分支关联的指针；它并不意味着删除分支下创建的所有提交，或类似的东西。
* 运行时间：应相对于任何重要指标保持恒定。
* 失败案例：如果给定名称的分支不存在，则中止。打印错误消息“A branch with that name does not exist.”。如果你尝试删除当前所在的分支，则中止，并打印错误消息“Cannot remove the current branch.”
* 有危险吗？不
* 我们的行数：~15

#### reset

* 用法：java gitlet.Main reset [提交ID]
* 检出给定提交所跟踪的所有文件。移除在该提交中不存在的已跟踪文件。同时将当前分支的头部移动到该提交节点。参见简介了解使用reset后头部指针会发生什么。[提交ID]可以像checkout一样进行缩写。暂存区被清空。该命令本质上是对任意提交的检出，并且还会更改当前分支头部。
* 运行时间：应该与给定提交的快照所跟踪的文件总大小呈线性关系。应该与任何涉及提交次数的度量保持恒定。
* 失败案例：如果给定id的提交不存在，则打印“No commit with that id exists.”。如果当前分支中有一个未跟踪的工作文件，并且该文件将被重置覆盖，则打印“There is an untracked file in the way; delete it, or add and commit it first.”然后退出；在进行任何其他操作之前执行此检查。
* 危险吗？是的！
* 与真实git的差异：此命令最接近使用--hard选项，例如git reset --hard [提交哈希]
* 我们的代码行数约为10行。我们是怎么得到这么少的代码行数的？记住你应该重用你的代码 :) 

#### merge

* 用法：java gitlet.Main merge [分支名称]
* 描述：将指定分支的文件合并到当前分支。这种方法有点复杂，所以这里有一个更详细的描述：首先考虑我们所说的当前分支和给定分支的分裂点。例如，如果master是当前分支，而branch是给定分支：分叉点是指当前分支和给定分支的最新共同祖先：- 一个共同祖先是指从两个分支头部都可以到达的提交记录（可以通过0个或多个父指针路径到达）。- 一个最新的共同祖先是指不是其他任何共同祖先的祖先的共同祖先。例如，虽然上图中最左侧的提交记录是master和branch的共同祖先，但它也是其右侧立即那个提交记录的祖先，所以它不是最新的共同祖先。如果分叉点与给定分支是同一个提交记录，那么我们什么也不做；合并完成，操作以消息“Given branch is an ancestor of the current branch.”结束。如果分叉点是当前分支，那么效果是检出给定分支，操作在打印消息“Current branch fast-forwarded.”后结束。否则，我们继续执行以下步骤。
  * 任何在给定分支自分叉点以来已修改但当前分支自分叉点未修改的文件，应更改为给定分支中的版本（从给定分支前面的提交中检出）。然后，所有这些文件应自动暂存。要澄清，如果一个文件是“在给定分支自分叉点以来已修改”，这意味着在给定分支前面的提交中存在的文件版本与分叉点的文件版本内容不同。记住：blob是内容寻址的！
  * 自分支点以来，当前分支中已修改但给定分支中未修改的任何文件应保持原样。
  * 任何在当前分支和给定分支中以相同方式修改的文件（即，两个文件现在具有相同的内容或都被删除）在合并时保持不变。如果一个文件从当前分支和给定分支中都被删除，但工作目录中存在同名文件，它将保持原样，继续在合并中不存在（不被跟踪也不被暂存）。
  * 任何在分割点不存在且仅存在于当前分支的文件应保持原样。
  * 任何在分割点不存在且仅存在于给定分支中的文件都应检出并暂存。
  * 在分支点存在的任何文件，在当前分支未经修改，且在指定分支中不存在，应被删除（并取消跟踪）。
  * 在任何分割点存在的文件，在给定分支中未经修改，并且在当前分支中不存在，则应保持不存在。
  * 当前分支和给定分支中以不同方式修改的任何文件都存在冲突。“以不同方式修改”可以指两个文件的内容都发生了变化且与其他不同，或者一个文件的内容发生了变化而另一个文件被删除，或者该文件在分支点时不存在，而在给定分支和当前分支中具有不同的内容。这样很好；那些因为不知道行终止符和行分隔符的区别而生产非标准、病态文件的人，自食其果。一旦文件已根据上述内容更新，并且分割点不是当前分支或给定分支，则自动合并并带有日志信息 Merged [给定分支名] into [当前分支名]。然后，如果合并遇到冲突，则在终端（而不是日志中）打印消息 Encountered a merge conflict。合并提交与其他提交不同：它们记录当前分支的头部（称为第一个父）和命令行中给定要合并的分支的头部作为父。顺便说一句，我们希望您已经注意到，提交集已经从简单的序列发展到树状结构，现在终于发展到了一个完整的有向无环图。
* 运行时间：O(NlgN+D)，其中N是两个分支中所有祖先提交的总数，D是这些提交下所有文件中的总数据量。
* 失败情况：如果存在暂存区的添加或删除操作，则打印错误信息“You have uncommitted changes.”并退出。如果给定名称的分支不存在，则打印错误信息“A branch with that name does not exist.”如果尝试合并分支到自身，则打印错误信息“Cannot merge a branch with itself.”如果合并会因所提交的提交没有更改而生成错误，则让正常的提交错误信息通过。如果当前提交中的未跟踪文件将被合并覆盖或删除，则打印“There is an untracked file in the way; delete it, or add and commit it first.”并退出；在执行任何其他操作之前执行此检查。
* 危险吗？是的！
* 与真实 Git 的区别：真实 Git 在合并文件时做得更微妙，只在两个文件自分叉点以来都发生变化的地方显示冲突。
  真实 Git 有不同的方式来决定使用多个可能的分叉点中的哪一个。
  真实 Git 会强制用户在提交之前解决合并冲突。Gitlet 只是提交合并，包括所有冲突，所以你必须使用单独的提交来解决问题。
  如果文件有未暂存的更改，而合并会更改这些文件，真实 Git 会报错。如果你想要这样做，也可以这样做，但我们不会测试这种情况。
* 我们的行数：~70

骨架相当简单，大部分是空的类。我们提供了有用的javadoc注释，暗示了你在每个文件中可能想要包含的内容。你应该遵循Capers的类似方法，其中你的主类本身不执行大量工作，而是简单地根据args调用其他方法。你绝对可以删除其他类或添加自己的类，但主类应该保持不变，否则我们的测试将无法找到你的代码。
如果你对从哪里开始感到困惑，我们建议你查看lab6

#### 评分细则

我们为Gitlet有二个评分器：检查点评分器、完整评分器。

* 检查点评分器。在Gradescope上提交到项目2：Gitlet Checkpoint自动评分器。

  它将测试：

  你的程序可以编译。
  你通过了骨架中的示例测试：testing/samples/*.in。这些测试要求你实现：
  init
  add
  commit,
  checkout -- [文件名]
  checkout [提交ID] -- [文件名]，以及
  log

  此外，它将进行评论（但不计分）：

  你是否通过了风格检查（目前它将忽略TODO类型的注释；最终提交时不会忽略。）
  我们将这些计分。EDITED 3/4：有编译器警告是可以的。

  你将有一个最大容量为1的令牌，每20分钟刷新一次。对于这些失败，你将不会得到完整的日志（即，你将被告知你失败的测试，但不会得到任何其他消息），但由于你有测试本身，你可以简单地本地调试。

* 完整评分器。完整的评分器是一个更庞大和全面的测试套件。请善待自己，并在过程中编写测试，这样您就不会过于依赖自动评分器来检查您的工作。与检查点类似，完整的评分器将提供关于每个测试做什么的英文提示，但不会提供实际的.in文件。

总共有16 + 32 + 64 = 112个额外的积分可能：
16分用于检查点
32分用于状态命令打印“尚未暂存以供提交的更改”和“未跟踪文件”部分
64分用于远程命令
本规范的其余部分充满了资源供你开始阅读。测试/调试部分将对你非常有帮助，因为在这个项目中的测试和调试将不同于以前的项目，但并不复杂。

#### 注意事项

呼！刚才要过那么多指令，真是不少。但别担心，不是所有指令的难度都一样。你可以看到每个指令完成每个部分大约用了多少行代码（这仅计算特定指令的代码——它不会重复计算在多个指令中重用的代码）。你不必担心完全匹配我们的解决方案，但希望这能让你对每个指令消耗的相对时间有一个大概的了解。merge指令比其他指令更复杂，所以不要把它留到最后做！

这个项目需要读取和写入文件。为了执行这些操作，你可能发现java.io.File和java.nio.file.Files这两个类很有帮助。实际上，你可能会在java.io和java.nio包中找到各种有用的东西。务必阅读gitlet.Utils包，里面包含了我们为你编写的一些其他工具。如果你仔细研究一下所有这些内容，可能会发现一些方法，这将使这个项目的io部分变得非常简单！有一个警告：如果你发现自己在使用读取器、写入器、扫描器或流，那么你正在让事情变得比实际需要的更复杂。

如果你思考Gitlet，你会注意到每次运行程序时只能运行一个命令。为了成功地完成你的版本控制系统，你需要在命令之间记住提交树。这意味着你不仅要设计一组类来表示执行期间内部Gitlet结构，还需要在你的.gitlet目录中的文件里有一个类似的表现形式，这将跨越多次程序运行。

如前所述，方便的做法是将需要永久存储在文件中的运行时对象进行序列化。Java运行时负责处理将哪些字段转换为字节以及如何转换的所有工作。

然而，有一个烦人的细节需要注意：Java序列化遵循指针。也就是说，不仅是你传递给writeObject的对象会被序列化和写入，它所指向的任何对象也会被序列化和写入。例如，如果你的提交内部表示使用指针指向其他提交对象来表示父提交，那么写入一个分支的头部将会把整个提交子图中的所有提交（和blob）写入到一个文件中，这通常不是你想要的结果。为了避免这种情况，不要在运行时对象中使用Java指针来引用提交和blob，而是使用SHA-1哈希字符串。在这些字符串和它们所引用的运行时对象之间维护一个运行时映射。你在Gitlet运行时创建并填充这个映射，但永远不要把它读或写到一个文件中。

#### 额外分数

##### add-remote

* 用法：java gitlet.Main add-remote [远程仓库名] [远程目录名称]/.gitlet
* 描述：将给定的登录信息保存在指定的远程名称下。然后，从指定的远程名称尝试推送或拉取时，将尝试使用此 .gitlet 目录。通过编写，例如，java gitlet.Main add-remote other ../testing/otherdir/.gitlet，您可以提供可在所有位置（在您的家用计算机或评分程序的软件中）工作的远程测试。在这些命令中始终使用正斜杠。请让您的程序将所有正斜杠转换为路径分隔符字符（在 Unix 上为正斜杠，在 Windows 上为反斜杠）。Java 有用地定义了类变量 java.io.File.separator 为此字符。
* 失败情况：如果给定名称的远程已存在，打印错误消息：“A remote with that name already exists.”。你不必检查用户名和服务器信息是否合法。
* 有危险吗？不。

##### rm-remote

* 用法：java gitlet.Main rm-remote [远程仓库名]
* 描述：删除与给定远程名称关联的信息。这里的想法是，如果你想要更改你添加的远程，你必须首先删除它，然后重新添加它。
* 失败案例：如果给定名称的远程不存在，则打印错误消息：“A remote with that name does not exist.”
* 有危险吗？不。

##### push

* 用法：java gitlet.Main push [远程仓库名] [远程分支名]

*  描述：尝试将当前分支的提交追加到给定远程仓库中指定分支的末尾。详情：

  该命令只有在远程分支的HEAD位于当前本地分支的历史记录中时才有效，这意味着本地分支包含远程分支未来的某些提交。在这种情况下，将未来的提交附加到远程分支。然后，远程分支应该重置到附加提交的前端（这样它的HEAD将与本地HEAD相同）。这称为快速前移。如果远程机器上的Gitlet系统存在但没有输入分支，则只需将分支添加到远程Gitlet。

*  失败案例：如果远程分支的头部不在当前本地头的历史中，请打印错误消息“Please pull down remote changes before pushing.”。如果远程 .gitlet 目录不存在，请打印“Remote directory not found.”

* 有危险吗？不。

##### fetch

* 用法：java gitlet.Main fetch [远程名称] [远程分支名称]
*  描述：将远程 Gitlet 仓库中的提交下载到本地 Gitlet 仓库中。基本上，这会将远程仓库中给定分支的所有提交和 blob（那些当前仓库中不存在的）复制到本地 .gitlet 中的名为 [remote name]/[remote branch name] 的分支中（就像在真实 Git 中一样），并将 [remote name]/[remote branch name] 更改为指向头提交（从而将远程仓库中的分支内容复制到当前仓库中）。如果本地仓库中之前不存在该分支，则会创建该分支。
*  失败案例：如果远程 Gitlet 仓库没有给定的分支名称，则打印错误消息“That remote does not have that branch.”。如果远程 .gitlet 目录不存在，则打印“Remote directory not found.”
* 有危险吗？不。

##### pull

*  用法：java gitlet.Main pull [远程仓库名称] [远程分支名称]
*  描述：作为获取命令，获取分支[远程名称]/[远程分支名称]，然后将该获取合并到当前分支。
*  失败案例：仅将fetch和merge的失败案例合并在一起。
* 有危险吗？不。

### 2. Gitlet 功能实现



